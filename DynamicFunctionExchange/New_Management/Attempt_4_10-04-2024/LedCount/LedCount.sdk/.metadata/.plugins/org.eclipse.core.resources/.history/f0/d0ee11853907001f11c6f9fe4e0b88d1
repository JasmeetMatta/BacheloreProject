//#include "xparameters.h"	/* XPAR parameters */
//#include "xhwicap.h"		/* HwIcap device driver */
//#include "xintc.h"		/* Interrupt controller device driver */
//#include "xinterrupt_wrap.h"
//#include "xil_exception.h"      /* Exceptions */
//#include "xil_printf.h"
//
//
//#ifndef SDT
//#define HWICAP_DEVICE_ID		XPAR_HWICAP_0_DEVICE_ID
//#define INTC_DEVICE_ID			XPAR_INTC_0_DEVICE_ID
//#define HWICAP_IRPT_INTR		XPAR_INTC_0_HWICAP_0_VEC_ID
//#else
//#define HWICAP_BASEADDR			XPAR_HWICAP_0_BASEADDR
//#endif
//
//
//#define TEST_WRITE_BUFFER_SIZE		1266095
//
//
//int HwIcapIntrExample(XHwIcap *HwIcapInstancePtr, UINTPTR BaseAddress);
//
//
//void HwIcapIntrHandler(void *CallBackRef, u32 StatusEvent, u32 WordCount);
//
//
//static XHwIcap  HwIcapInstance;	/* The instance of the HwIcap device */
//
//
//volatile int TransferInProgress;
//
//int Error;
//
//u32 WriteBuffer[TEST_WRITE_BUFFER_SIZE];
//
//
//int CheckHwicapInterrupt(void)
//{
//	int Status;
//	/*
//	 * Run the HwIcap Interrupt example.
//	 */
//	Status = HwIcapIntrExample(&HwIcapInstance, HWICAP_BASEADDR);
//	if (Status != XST_SUCCESS) {
//		xil_printf("Hwicap interrupt Example Failed\r\n");
//		return XST_FAILURE;
//	}
//
//	xil_printf("Successfully ran Hwicap interrupt Example\r\n");
//	return XST_SUCCESS;
//}
//
//
//int HwIcapIntrExample(XHwIcap *HwIcapInstancePtr, UINTPTR BaseAddress)
//{
//	int Status;
//	u32 Count;
//	u8 Test;
//	XHwIcap_Config *ConfigPtr;
//
//	/*
//	 * Initialize the HwIcap driver.
//	 */
//	ConfigPtr = XHwIcap_LookupConfig(BaseAddress);
//	if (ConfigPtr == NULL) {
//		return XST_FAILURE;
//	}
//	Status = XHwIcap_CfgInitialize(HwIcapInstancePtr,
//				       ConfigPtr,
//				       ConfigPtr->BaseAddress);
//	if (Status != XST_SUCCESS) {
//		return XST_FAILURE;
//	}
//
//	/*
//	 * Perform a self-test to ensure that the hardware was built correctly.
//	 */
//	Status = XHwIcap_SelfTest(HwIcapInstancePtr);
//
//	if (Status != XST_SUCCESS) {
//		return XST_FAILURE;
//	}
//
//	/*
//	 * Connect the HwIcap device to the interrupt subsystem such that
//	 * interrupts can occur. This function is application specific.
//	 */
//
//	Status = XSetupInterruptSystem(HwIcapInstancePtr, XHwIcap_IntrHandler,
//				       HwIcapInstancePtr->HwIcapConfig.IntrId,
//				       HwIcapInstancePtr->HwIcapConfig.IntrParent,
//				       XINTERRUPT_DEFAULT_PRIORITY);
//
//	if (Status != XST_SUCCESS) {
//		return XST_FAILURE;
//	}
//
//	/*
//	 * Setup the handler for the HwIcap that will be called from the
//	 * interrupt context when an HwIcap status occurs, specify a pointer
//	 * to the HwIcap driver instance as the callback reference so the
//	 * handler is able to access the instance data.
//	 */
//	XHwIcap_SetInterruptHandler(HwIcapInstancePtr, HwIcapInstancePtr,
//				    (XHwIcap_StatusHandler)HwIcapIntrHandler);
//
//	/*
//	 * Initialize the write buffer with pattern to write.
//	 */
//	for (Count = 0; Count < TEST_WRITE_BUFFER_SIZE;) {
//
//		WriteBuffer[Count++] = XHI_DUMMY_PACKET;
//		WriteBuffer[Count++] = XHI_SYNC_PACKET;
//		WriteBuffer[Count++] = XHwIcap_Type1Read(XHI_IDCODE) | 1;
//		WriteBuffer[Count++] = XHI_NOOP_PACKET;
//		WriteBuffer[Count++] = XHI_NOOP_PACKET;
//		WriteBuffer[Count++] = XHI_DUMMY_PACKET;
//		WriteBuffer[Count++] = XHI_SYNC_PACKET;
//		WriteBuffer[Count++] = XHwIcap_Type1Read(XHI_COR) | 1;
//		WriteBuffer[Count++] = XHI_NOOP_PACKET;
//		WriteBuffer[Count++] = XHI_NOOP_PACKET;
//	}
//
//	/*
//	 * Enable the Write FIFO Half Full Interrupt.
//	 */
//	XHwIcap_IntrEnable(HwIcapInstancePtr, XHI_IPIXR_WRP_MASK);
//
//	/*
//	 * Write the the data to the device.
//	 */
//	TransferInProgress = TRUE;
//	Status = XHwIcap_DeviceWrite(HwIcapInstancePtr,
//				     (u32 *) &WriteBuffer[0],
//				     TEST_WRITE_BUFFER_SIZE);
//	if (Status != XST_SUCCESS)  {
//		return XST_FAILURE;
//	}
//
//	/*
//	 * Wait for the data to be written to the device.
//	 */
//	while (TransferInProgress);
//
//	return XST_SUCCESS;
//}
//
//void HwIcapIntrHandler(void *CallBackRef, u32 StatusEvent, u32 ByteCount)
//{
//	/*
//	 * Indicate the transfer between the HwIcap to the Icap device is done
//	 * regardless of the status event.
//	 */
//	TransferInProgress = FALSE;
//
//	/*
//	 * If the event was not transfer done, then track it as an error.
//	 */
//	if (StatusEvent != XST_HWICAP_WRITE_DONE) {
//		Error++;
//	}
//}
//
//
//static int HwIcapSetupInterruptSystem(XIntc *IntcInstancePtr, XHwIcap *HwIcapPtr, u16 IntrId )
//{
//	int Status;
//
//	/*
//	 * Initialize the interrupt controller driver so that it's ready to use.
//	 */
//	Status = XIntc_Initialize(IntcInstancePtr, INTC_DEVICE_ID);
//	if (Status != XST_SUCCESS) {
//		return XST_FAILURE;
//	}
//
//	/*
//	 * Connect the handler that will be called when an interrupt
//	 * for the device occurs, the handler defined above performs the
//	 * specific interrupt processing for the device.
//	 */
//	Status = XIntc_Connect(IntcInstancePtr,
//			       IntrId,
//			       (XInterruptHandler) XHwIcap_IntrHandler,
//			       HwIcapPtr);
//	if (Status != XST_SUCCESS) {
//		return XST_FAILURE;
//	}
//
//	/*
//	 * Start the interrupt controller so interrupts are enabled for all
//	 * devices that cause interrupts. Specify real mode so that the
//	 * HwIcap device can cause interrupts through the interrupt
//	 * controller.
//	 */
//	Status = XIntc_Start(IntcInstancePtr, XIN_REAL_MODE);
//	if (Status != XST_SUCCESS) {
//		return XST_FAILURE;
//	}
//
//	/*
//	 * Enable the interrupt for the HwIcap device.
//	 */
//	XIntc_Enable(IntcInstancePtr, IntrId);
//
//	/*
//	 * Initialize the exception table.
//	 */
//	Xil_ExceptionInit();
//
//	/*
//	 * Register the interrupt controller handler with the exception table.
//	 */
//	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
//				     (Xil_ExceptionHandler) XIntc_InterruptHandler,
//				     IntcInstancePtr);
//	/*
//	 * Enable non-critical exceptions.
//	 */
//	Xil_ExceptionEnable();
//
//	return XST_SUCCESS;
//}
